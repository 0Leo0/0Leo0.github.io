<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lovelife</title>
  
  <subtitle>时光荏苒，岁月静好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0Leo0.github.io/"/>
  <updated>2018-11-21T09:52:53.487Z</updated>
  <id>https://0Leo0.github.io/</id>
  
  <author>
    <name>Leowen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV_python3_05</title>
    <link href="https://0Leo0.github.io//2018/OpenCV_python3_05.html"/>
    <id>https://0Leo0.github.io//2018/OpenCV_python3_05.html</id>
    <published>2018-11-20T04:17:50.000Z</published>
    <updated>2018-11-21T09:52:53.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="Practical-Python-and-OpenCV-3rd-Edition-05"><a href="#Practical-Python-and-OpenCV-3rd-Edition-05" class="headerlink" title="Practical Python and OpenCV,3rd Edition 05"></a>Practical Python and OpenCV,3rd Edition 05</h2><hr><h3 id="图像算术-image-arithmetic"><a href="#图像算术-image-arithmetic" class="headerlink" title="图像算术(image arithmetic)"></a>图像算术(image arithmetic)</h3><p>我们都知道基本的算术运算，如加法和减法。但是在处理图像时，我们需要记住颜色空间和数据类型的限制。</p><p>例如，RGB图像具有落在[0,255]范围内的像素。那么如果我们正在检查强度为250的像素并尝试向它添加10，会发生什么？</p><p>在正常的算术规则下，我们最终得到的值为260.但是，由于RGB图像表示为8位无符号整数，因此260不是有效值。</p><p>那么，会发生什么？我们是否应该执行某种检查以确保没有像素落在[0,255]范围之外，从而将所有像素剪切为最小值0和最大值255？</p><p>或者我们应用模数运算，并“wrap around(环绕)”？在模数规则下，添加10到250将简单地回绕到值4。</p><p>哪种方式是处理超出[0,255]范围的图像添加和减法的“正确”方法？</p><p>答案是没有正确的方法——它只取决于你如何操纵像素以及你想要的结果。</p><p>但是，请务必记住OpenCV和NumPy加法之间存在差异。NumPy将执行模运算和“warp around”。另一方面，OpenCV将执行裁剪并确保像素值永远不会超出范围[0,255]</p><p>请看代码：</p><pre><code>from __future__ import print_functionimport numpy as np import argparse import cv2 ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,        help=&quot;path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)print(&quot;max of 255: {}&quot;.format(cv2.add(np.uint8([200]),np.uint8([100]))))print(&quot;min of 0: {}&quot;.format(cv2.add(np.uint8([50]),np.uint8([100]))))print(&quot;wrap around: {}&quot;.format(np.uint8([200]) + np.uint8([100])))print(&quot;wrap around: {}&quot;.format(np.uint8([50]) - np.uint8([100])))</code></pre><p><strong>解释</strong>：</p><p>第一个print函数，我们定义了两个8位无符号整数的NumPy数组。第一个数组有一个元素：值为200.第二个数组也只有一个元素，但值为100.然后我们使用OpenCV的cv2.add方法将值一起添加。那么返回的值到底回事多少呢？那么，根据标准算术规则，我们认为结果应该是300，但是，请记住，我们正在使用8位无符号整数，其范围仅在[0,255]之间。由于我们使用的是cv2.add方法，OpenCV会为我们处理剪切，并确保添加产生的最大值为255.当我们执行此代码时，我们可以看到返回值是255。</p><p>第二个print函数，我们使用cv2.subtract执行减法。同样，我们定义了两个NumPy数组，每个数组都有一个元素，以及8位无符号整数数据类型。第一个数组的值为50，第二个数组的值为100。根据算术规则，返回值本该是-50，但是OpenCV再一次为我们进行裁剪，返回值会是0.</p><p>max of 255: [[255]]</p><p>min of 0: [[0]]</p><p>但是如果我们使用NumPy来执行算术而不是OpenCV会发生什么？</p><p>第三个print函数，首先，我们定义两个NumPy数组，每个数组都有一个元素，以及8位无符号整数数据类型。 第一个数组的值为200，第二个数组的值为100.使用cv2.add函数，我们的添加将被剪切并返回值255。但是Numpy并不会执行裁剪。它会执行模运算并”warps around(环绕)”。一旦值达到255，Numpy将回绕到0并再一次向上技术，直到100 steps reached。</p><p>第四个print函数，在减法期间一旦达到0，模运算操作就会回绕并从255开始向后计数。</p><p>wrap around: [44]</p><p>wrap around: [206]</p><p>现在我们已经在OpenCV和NumPy中探讨了图像算法的注意事项，让我们对实际图像执行算法并查看结果：</p><pre><code>M = np.ones(image.shape,dtype=&quot;uint8&quot;) * 100added = cv2.add(image,M)cv2.imshow(&quot;Added&quot;,added)M = np.ones(image.shape,dtype=&quot;uint8&quot;) * 50 subtracted = cv2.subtract(image,M)cv2.imshow(&quot;Subtracted&quot;,subtracted)cv2.waitKey(0)</code></pre><p>显示效果:</p><p><img src="https://i.imgur.com/SKd6AO8.png" alt=""></p><p><strong>解释</strong>：</p><p>我们首先定义了一个NumPy数组，其大小与我们的图像相同 同样，我们肯定使用8位无符号整数作为我们的数据类型。为了用100的值而不是1来填充我们的矩阵，我们简单地将1的矩阵乘以100.最后，我们使用cv2.add函数将我们的100的矩阵添加到原始图像——从而增加每个像素强度 图像乘以100，但如果它们试图超过255，则确保所有值都被剪切到范围[0,255]。</p><p>同样的，我们再定义了一个NumPy数组，并将原始图像减去50个像素，最后，曾经是白色的像素现在看起来是灰色的。这是因为我们从像素中减去50并将它们推向RGB颜色空间的较暗区域。</p><p><strong>用到的函数</strong></p><p><span id="inline-blue">cv2.add</span></p><p><span id="inline-blue">cv2.subtract</span></p><h3 id="更多的参考："><a href="#更多的参考：" class="headerlink" title="更多的参考："></a>更多的参考：</h3><p><a href="https://ppao.pyimagesearch.com/lessons/ppao-chapter-6-image-processing/" target="_blank" rel="noopener">PPaO Chapter 6 – Image Processing</a></p><hr>]]></content>
    
    <summary type="html">
    
      第五个代码
    
    </summary>
    
      <category term="计算机视觉" scheme="https://0Leo0.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Oepncv" scheme="https://0Leo0.github.io/tags/Oepncv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV_python3_04</title>
    <link href="https://0Leo0.github.io//2018/OpenCV_python3_04.html"/>
    <id>https://0Leo0.github.io//2018/OpenCV_python3_04.html</id>
    <published>2018-11-16T14:17:50.000Z</published>
    <updated>2018-11-16T15:56:01.894Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="Practical-Python-and-OpenCV-3rd-Edition-04"><a href="#Practical-Python-and-OpenCV-3rd-Edition-04" class="headerlink" title="Practical Python and OpenCV,3rd Edition 04"></a>Practical Python and OpenCV,3rd Edition 04</h2><hr><h3 id="图像转换-image-transformations"><a href="#图像转换-image-transformations" class="headerlink" title="图像转换(image transformations)"></a>图像转换(image transformations)</h3><p>本节中，我们将介绍基本的图像转换。 这些是您可能应用于图像的常用技术，包括平移，旋转，调整大小，翻转和裁剪。</p><h4 id="平移-Translation"><a href="#平移-Translation" class="headerlink" title="平移(Translation)"></a>平移(Translation)</h4><p>我们首先介绍的是Translation。Trans Latino是沿x和y轴移动图像。 使用Translation，我们可以向上，向下，向左或向右移动图像，以及上述任意组合！请看下面的代码(translation.py)：</p><pre><code>import numpy as np import argparse import imutils import cv2 ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,    help=&quot;path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)M = np.float32([[1,0,25],[0,1,50]])shifted = cv2.warpAffine(image,M,(image.shape[1],image.shape[0]))cv2.imshow(&quot;Shifted Down and Right&quot;,shifted)M = np.float32([[1,0,-50],[0,1,-90]])shifted = cv2.warpAffine(image,M,(image.shape[1],image.shape[0]))cv2.imshow(&quot;Shifted Up and Left&quot;,shifted)</code></pre><p><strong>解释</strong>:</p><p>主要从M——我们的的translation matrix讲起，该矩阵告诉我们的图像要进行平移多少像素(从左到右，从上到下)。该矩阵被定义为float32类型的数组，因为OpenCV希望该矩阵是一个float类型。The first row of the matrix is [1,0,t<sub>x</sub>]，其中t<sub>x</sub>是the number of pixels we will shift the image left or right，而负值则表示图像将向左平移，正值表示图像将向右平移。然后我们定义the second row of the matrix as [0,1,t<sub>y</sub>]，其中，t<sub>y</sub>是the number of pixels we will shift the image up or down。其中，负值表示图像向上平移，正值表示图像向下平移。</p><p>使用了上面的那个标记，我们看代码中，将t<sub>x</sub>=25,t<sub>y</sub>=50则意味着，我们将图像向右平移25个像素，向下平移50个像素。</p><p>我们定义好了平移矩阵之后，图像的实际平移是使用了<code>cv2.warpAffine</code>函数来执行，该函数的第一个参数是我们要进行平移的图像，第二个参数是我们的平移矩阵M，最后我们需要手动地提供图像的尺寸(width and height)作为第三个参数。</p><p>前面实现了图像的平移，但是代码太过冗余，我们新建一个<code>.py</code>文件来实现平移功能(imutils.py)</p><pre><code>import numpy as np import cv2 def translate(image,x,y):    M = np.float32([[1,0,x],[0,1,y]])    shifted = cv2.warpAffine(image,M,(image.shape[1],image.shape[0]))    return shifted</code></pre><p><strong>解释</strong>:</p><p>我们的平移方法有三个参数：我们要平移的图像，我们沿x轴移动的像素数，以及我们将沿y轴移动的像素数。然后，此方法定义我们的平移矩阵M，然后再应用实际移位。最后，我们返回移位后的图像。</p><p>修改translation.py的内容</p><pre><code>shifted = imutils.translate(image,0,100)cv2.imshow(&quot;Shifted Down&quot;,shifted)cv2.waitKey(0)</code></pre><p>运行结果：</p><p><img src="https://i.imgur.com/174QVuy.png" alt=""></p><h4 id="旋转-Rotation"><a href="#旋转-Rotation" class="headerlink" title="旋转(Rotation)"></a>旋转(Rotation)</h4><p>在这里，我们将使用θ来表示要旋转多少度。</p><p>rotate.py</p><pre><code>import numpy as np import argparse import imutilsimport cv2ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,    help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)(h,w) = image.shape[:2]center = (w // 2, h // 2)M = cv2.getRotationMatrix2D(center,45,1.0)rotated = cv2.warpAffine(image,M,(w,h))cv2.imshow(&quot;Rotated by 45 Degrees&quot;,rotated)M = cv2.getRotationMatrix2D(center,-90,1.0)rotated = cv2.warpAffine(image,M,(w,h))cv2.imshow(&quot;Rotated by -90 Degrees&quot;,rotated)</code></pre><p><strong>解释</strong>:</p><p>前面还是导入必要的包以及解析输入参数和显示原始图像。</p><p>当我们旋转图像时，我们需要指定我们想要旋转的点。 在大多数情况下，您需要围绕图像的中心旋转; 我们首先获取图像的宽度和高度，因为OpenCV将图像读取为一个numpy数组，所以和矩阵类似，矩阵的行对应着高，也就是<code>height=image.shape[0]</code>，矩阵的列对应着图像的宽，也就是<code>width=image.shape[1]</code>，然后我们除以2，确定图像的中心位置。这里我们使用和C语言一样的除法，//表示整除法，以确保我们得到的是整数。</p><p>就像我们定义一个矩阵来平移图像一样，我们也定义了一个矩阵来旋转图像。 不是使用NumPy手动构造矩阵，而是调用<code>cv2.getRotationMatrix2D</code>方法。</p><p><code>cv2.getRotationMatrix2D</code>函数有三个参数：第一个是我们想要旋转图像的点，在这里是图像的中心位置，然后我们指定需要旋转的角度θ，我们第一次是旋转了45度，最后一个参数图像的比例。我们还没有讨论调整图像的大小，但是在这里你可以指定浮点值，其中1.0表示使用相同的图像尺寸。 但是，如果指定值为2.0，则图像的大小将加倍。 类似地，值0.5将图像的大小减半。</p><p>一旦我们从<code>cv2.getRotationMatrix2D</code>函数获得旋转矩阵M，我们就可以使用<code>cv2.warpAffine</code>方法将旋转应用于我们的图像。此函数的第一个参数是我们想要旋转的图像。然后，我们指定旋转矩阵M以及图像的输出尺寸（宽度和高度）。然后，显示旋转了的图像。</p><p>显示效果为：</p><p><img src="https://i.imgur.com/iseOU2P.png" alt=""></p><p>接下来为了让代码更加的pretty and Pythonic，我们在imutils.py中添加一个rotate方法</p><pre><code>def rotate(image,angle,center=None,scale=1.0):    (h,w) = image.shape[:2]    if center is None:        center = (w // 2 , h // 2)    M = cv2.getRotationMatrix2D(center,angle,scale)    rotated = cv2.warpAffine(image,M,(w,h))    return rotated</code></pre><p><strong>解释</strong>：</p><p>我们的rotate方法有四个参数。第一个是你的image。第二个是我们想要旋转图像的角度θ。我们提供两个可选的关键字参数，center和scale。center参数是我们希望旋转图像的点。如果提供了值None，则该方法自动选图像中心为旋转点。最后，scale参数用于处理在旋转期间是否应更改图像的大小。scale参数的默认值为1.0，这意味着不应调整大小。</p><p>再次修改rotate.py文件，</p><pre><code>rotated = imutils.rotate(image,180)cv2.imshow(&quot;Rotated by 180 Degrees&quot;,rotated)cv2.waitKey(0)</code></pre><p>运行结果：</p><p><img src="https://i.imgur.com/WqibdLD.png" alt=""></p><p>确实很pythonic！！！</p><h4 id="Resizing"><a href="#Resizing" class="headerlink" title="Resizing"></a>Resizing</h4><pre><code>import numpy as np import argparseimport imutilsimport cv2 ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)</code></pre><p><strong>解释</strong>：</p><p>这个和前面一样，解析参数，读取图片并显示图片</p><pre><code>r = 150.0 / image.shape[1]dim = (150,int(image.shape[0] * r))resized = cv2.resize(image,dim,interpolation=cv2.INTER_AREA)cv2.imshow(&quot;Resized (Width)&quot;,resized)</code></pre><p><strong>解释</strong>：</p><p><code>r</code>表示<code>the aspect ratio</code>。这里<code>image.shape[1]</code>表示我们图片的宽度，上面的代码我们设置我们图片的新宽度为150个pixels，为了计算新高度与旧高度的比率，我们简单地将比率r定义为新宽度（150像素）除以旧宽度，接着为了保持宽高比，我们计算出高度(height)的变化为 <code>height / width * 150</code>。接下来调用resize函数，该函数的第一个参数是我们希望调整大小的图像，第二个参数是我们为新图像计算的尺寸。最后一个参数是我们的插值方法，这是在背后工作的算法 处理实际图像的大小调整方式。一般来说，我发现使用cv2.INTER_AREA在调整大小时获得最佳效果; 但是，其他适当的选择包括cv2.INTER_LINEAR，cv2.INTER_CUBIC和cv2.INTER_NEAREST。</p><pre><code>r = 50.0 / image.shape[0]dim = (int(image.shape[1] * r),50)resized = cv2.resize(image,dim,interpolation=cv2.INTER_AREA)cv2.imshow(&quot;Resized (Height)&quot;,resized)cv2.waitKey(0)</code></pre><p><strong>解释</strong>：</p><p>这一段代码和前一段类似，只不过这一次是固定高度为50个像素，然后保持宽高比计算出宽度，显示图像。</p><pre><code>resized = imutils.resize(image,width = 100)cv2.imshow(&quot;Resized via Function&quot;,resized)cv2.waitKey(0)</code></pre><p><strong>解释</strong>：</p><p>前面都是用了三行代码实现图像的resize，我们可以利用<code>imutils.resize</code>函数只需要一行即可实现一样的功能。</p><p>在<code>imutils.py</code>函数中实现：</p><pre><code>def resize(image,width=None,height=None,inter=cv2.INTER_AREA):    dim = None     (h,w) = image.shape[:2]    if width is None and height is None:        return image     if width is None:        r = height / float(h)        dim = (int(w * r),height)    else:        r = width / float(w)        dim = (width,int(h * r))    resized = cv2.resize(image,dim,interpolation=inter)    return resized</code></pre><p><strong>解释</strong>：</p><p> 第一个参数是我们想要调整大小的图像。然后，我们定义两个关键字参数，宽度和高度。这两个参数都不能为None，否则我们将不知道如何调整图像大小。我们还提供inter，这是我们的插值方法，默认为cv2.INTER_AREA。</p><p>显示效果：</p><p><img src="https://i.imgur.com/wmyegIu.png" alt=""></p><h4 id="Flipping"><a href="#Flipping" class="headerlink" title="Flipping"></a>Flipping</h4><p>接下来我们要探索的图像转换是翻转图像。 我们可以围绕x或者翻转图像y轴，甚至两者。查看下图理解一下水平和垂直翻转的区别。</p><p><img src="https://i.imgur.com/5hkYcNH.png" alt=""></p><pre><code>import argparseimport cv2ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,    help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)</code></pre><p><strong>解释</strong>：<br>和前面一样，解析参数，显示原始图片</p><pre><code>flipped = cv2.flip(image,1)cv2.imshow(&quot;Flipped Horizontally&quot;,flipped)flipped = cv2.flip(image,0)cv2.imshow(&quot;Flipped Vertically&quot;,flipped)flipped = cv2.flip(image,-1)cv2.imshow(&quot;Flipped Horizontally &amp; Vertically&quot;,flipped)cv2.waitKey(0)</code></pre><p>我们通过调用cv2.flip函数来完成图像的翻转。cv2.flip方法需要两个参数：我们要翻转的图像和a flip code，用于确定我们如何翻转图片。</p><p>使用翻转代码值1表示我们将围绕y轴水平翻转图像。指定翻转代码为0表示我们想要围绕x轴垂直翻转图像。最后，使用负翻转代码翻转两个轴图像。</p><p>显示效果：</p><p><img src="https://i.imgur.com/ghs5Ha6.png" alt=""></p><h4 id="Cropping"><a href="#Cropping" class="headerlink" title="Cropping"></a>Cropping</h4><p>当我们裁剪图像时，我们想要删除我们不感兴趣的图像的外部部分。我们可以使用NumPy数组切片来完成图像裁剪。</p><pre><code>import numpy as np import argparseimport cv2 ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,    help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)cropped = image[30:120,240:335]cv2.imshow(&quot;T-Rex Face&quot;,cropped)cv2.waitKey(0)</code></pre><p><strong>解释</strong>：</p><p>实际裁剪在一行代码上进行。我们提供NumPy数组切片以提取图像的矩形区域，从（240,30）开始到（335,120）结束。The order in which we supply the<br>indexes to the crop may seem counterintuitive(有悖常理); 但请记住，OpenCV将图像表示为NumPy数组，其高度优先，宽度为次之。这意味着我们需要在x轴之前提供y轴值.</p><p>为了执行我们的裁剪，NumPy需要四个索引：</p><ol><li><p>开始y：起始y坐标。在这种情况下，我们从y=30开始。</p></li><li><p>结束y：结束y坐标。我们将在y=120时结束我们的裁剪。</p></li><li><p>开始x：切片的起始x坐标。我们在x=240时开始裁剪</p></li><li><p>结束x：切片的结束x轴坐标。我们的切片在x=335处结束</p></li></ol><p>显示效果:</p><p><img src="https://i.imgur.com/HkU9bOf.png" alt=""></p><p><strong>用到的函数</strong></p><p><span id="inline-blue">cv2.warpAffine</span></p><p><span id="inline-blue">cv2.getRotationMatrix2D</span></p><p><span id="inline-blue">cv2.resize</span></p><h3 id="更多的参考："><a href="#更多的参考：" class="headerlink" title="更多的参考："></a>更多的参考：</h3><p><a href="https://ppao.pyimagesearch.com/lessons/ppao-chapter-5-drawing/" target="_blank" rel="noopener">chapter-5-drawing</a></p><hr>]]></content>
    
    <summary type="html">
    
      第四个代码
    
    </summary>
    
      <category term="计算机视觉" scheme="https://0Leo0.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Oepncv" scheme="https://0Leo0.github.io/tags/Oepncv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV_python3_03</title>
    <link href="https://0Leo0.github.io//2018/OpenCV_python3_03.html"/>
    <id>https://0Leo0.github.io//2018/OpenCV_python3_03.html</id>
    <published>2018-11-09T07:17:57.000Z</published>
    <updated>2018-11-09T09:18:55.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="Practical-Python-and-OpenCV-3rd-Edition-03"><a href="#Practical-Python-and-OpenCV-3rd-Edition-03" class="headerlink" title="Practical Python and OpenCV,3rd Edition 03"></a>Practical Python and OpenCV,3rd Edition 03</h2><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>import numpy as np import cv2 canvas = np.zeros((300,300,3),dtype=&quot;uint8&quot;)</code></pre><p><strong>解释</strong>:</p><p>前两个是导入python库，接着就构造一个Numpy数组，使用<code>.zeros</code>方法初始化一个300 rows 和 300 columns的矩阵(也就是说画布的大小为300x300=90000个像素大小)，同时还分配了3个channels，one for Red,Green,and Blue,respectively。同时需要注意的是数据类型，dtype。由于我们将图像表示为像素在[0,255]范围内的RGB图像，因此我们使用8位无符号整数或uint8。</p><pre><code>green = (0,255,0)cv2.line(canvas,(0,0),(300,300),green)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)red = (0,0,255)cv2.line(canvas,(300,0),(0,300),red,3)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)</code></pre><p><strong>解释</strong>:</p><p>前面我们初始化了我们的画布，接下来我们开始画直线，首先我们定义了一个元组(tuple)来定义画笔的颜色,这里是绿色，然后我们调用<code>.line</code>方法，该方法的第一个参数是我们绘制的画布，第二个参数是该line的起点，我们设置开始点为(0,0)，我们还需要为该line提供一个结束点（第三个参数）。我们将结束点设置为（300,300)，最后一个参数是我们画笔的颜色，我们设置为绿色。接着将我们的图像显示出来，并且wait for a keypress.</p><p>第二段代码的<code>.line</code>方法的最后一个参数3就是我们画笔的thickness了，也就是画笔的厚度了。</p><p>显示效果为：</p><p><img src="https://i.imgur.com/UtO0byw.png" alt=""></p><pre><code>cv2.rectangle(canvas,(10,10),(60,60),green)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)cv2.rectangle(canvas,(50,200),(200,225),red,5)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)blue = (255,0,0)cv2.rectangle(canvas,(200,50),(225,125),blue,-1)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)</code></pre><p><strong>解释</strong>:</p><p>第一段代码我们使用了<code>.rectangle</code>方法，该方法的第一个参数是我们要画的画布，第二个参数是我们的rectangle的starting(x,y)位置，这里我们设置我们rectangle的开始point为(10,10)，然后我们还得设置我们矩形的结束点为(60,60),这个时候我们定义了一个(60-10,60-10)=(50,50)大小的像素区域。最后一个就是我们矩形的颜色了。第二段代码的第一行的最后一个参数是画笔的厚度，第三段代码的最后一个参数表示绘制一个solid(实心)的矩形。</p><p>显示效果为：</p><p><img src="https://i.imgur.com/GaNsOuD.png" alt=""></p><pre><code>canvas = np.zeros((300,300,3),dtype=&quot;uint8&quot;)(centerX,centerY) = (canvas.shape[1] // 2 , canvas.shape[0] // 2)white = (255,255,255)for r in range(0,175,25):    cv2.circle(canvas,(centerX,centerY),r,white)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)</code></pre><p><strong>解释</strong>:</p><p>我们首先初始化我们的画布，然后我们计算两个变量：centerX和centerY。这两个变量代表图像中心的(x,y)的坐标。我们首先获取图像的宽度(也就是列)，通过<code>.shape[1]</code>获取，然后获取图像的高度(也就是行)，通过<code>.shape[0]</code>获取，最后用//(取C语言的除法，不保留小数)除以2获取中心位置。获取了圆心的位置，接下来，用一个for循环，starting from 0 and ending at 150，每一次增加25的半径来画圆。<code>.circle</code>方法的第一个参数是我们的画布，然后我们将圆心坐标传给第二个参数，第三个参数是我们的半径大小r，最后一个是我们的圆的颜色。</p><p>显示效果为：</p><p><img src="https://i.imgur.com/y9UMENC.png" alt=""></p><pre><code>for i in range(0,25):    radius = np.random.randint(5, high = 200)    color = np.random.randint(0, high = 256 , size = (3,)).tolist()    pt = np.random.randint(0, high = 300, size=(2,))    cv2.circle(canvas,tuple(pt),radius,color,-1)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)</code></pre><p><strong>解释</strong>:</p><p>接下来我们画25个圆，用一个for循环来实现。首先是半径，我们使用Numpy的<code>.random.randint</code>方法生成[5,200)范围内的半径值，接着用该方法生成RGB颜色，范围是[0,255],为了得到三个随机的整数，而不是一个整数，我们传递关键字参数<code>size=(3,)</code>,数字3表示有3个数据，这样我们就获取了由3个值为[0,255]的随机数组成的元组来表示我们的RGB颜色了。接着哦我们需要一个圆心的point，我们也设置pt为[0,300)的值，但是圆心只需要两个数字，即(x,y)即可，因此，<code>size=(2,)</code>。最后我们调用<code>.circle</code>方法来画我们的圆。</p><p>显示效果为：</p><p><img src="https://i.imgur.com/TiBFOQs.png" alt=""></p><p>运行程序</p><p><img src="https://i.imgur.com/Yh6tdId.png" alt=""></p><p>点击图片部分，按键盘任意键结束脚本。</p><p><strong>完整的代码</strong></p><pre><code>import numpy as np import cv2 canvas = np.zeros((300,300,3),dtype=&quot;uint8&quot;)green = (0,255,0)cv2.line(canvas,(0,0),(300,300),green)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)red = (0,0,255)cv2.line(canvas,(300,0),(0,300),red,3)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)cv2.rectangle(canvas,(10,10),(60,60),green)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)cv2.rectangle(canvas,(50,200),(200,225),red,5)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)blue = (255,0,0)cv2.rectangle(canvas,(200,50),(225,125),blue,-1)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)canvas = np.zeros((300,300,3),dtype=&quot;uint8&quot;)(centerX,centerY) = (canvas.shape[1] // 2 , canvas.shape[0] // 2)white = (255,255,255)for r in range(0,175,25):    cv2.circle(canvas,(centerX,centerY),r,white)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)for i in range(0,25):    radius = np.random.randint(5, high = 200)    color = np.random.randint(0, high = 256 , size = (3,)).tolist()    pt = np.random.randint(0, high = 300, size=(2,))    cv2.circle(canvas,tuple(pt),radius,color,-1)cv2.imshow(&quot;Canvas&quot;,canvas)cv2.waitKey(0)    </code></pre><p><strong>用到的函数</strong></p><p><span id="inline-blue">cv2.line</span></p><p><span id="inline-blue">cv2.rectangle</span></p><p><span id="inline-blue">cv2.circle</span></p><h3 id="更多的参考："><a href="#更多的参考：" class="headerlink" title="更多的参考："></a>更多的参考：</h3><p><a href="https://ppao.pyimagesearch.com/lessons/ppao-chapter-5-drawing/" target="_blank" rel="noopener">chapter-5-drawing</a></p><p>名词：</p><p>Regions of Interest(ROIs)</p><p>machine-readable zones(MRZs)</p><h3 id="小测试："><a href="#小测试：" class="headerlink" title="小测试："></a>小测试：</h3><p>请实现下图效果，尽可能用少的代码。</p><p><img src="https://i.imgur.com/ZeLD60d.png" alt=""></p><p><a href="https://ppao.pyimagesearch.com/wp-content/uploads/2016/08/chapter5_quiz.py_.zip" target="_blank" rel="noopener">答案下载地址</a></p><hr>]]></content>
    
    <summary type="html">
    
      第三个代码
    
    </summary>
    
      <category term="计算机视觉" scheme="https://0Leo0.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Oepncv" scheme="https://0Leo0.github.io/tags/Oepncv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV_python3_02</title>
    <link href="https://0Leo0.github.io//2018/OpenCV_python3_02.html"/>
    <id>https://0Leo0.github.io//2018/OpenCV_python3_02.html</id>
    <published>2018-11-09T03:17:57.000Z</published>
    <updated>2018-11-09T07:25:12.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="Practical-Python-and-OpenCV-3rd-Edition-02"><a href="#Practical-Python-and-OpenCV-3rd-Edition-02" class="headerlink" title="Practical Python and OpenCV,3rd Edition 02"></a>Practical Python and OpenCV,3rd Edition 02</h2><hr><h3 id="基础说明"><a href="#基础说明" class="headerlink" title="基础说明"></a>基础说明</h3><h4 id="什么是像素"><a href="#什么是像素" class="headerlink" title="什么是像素"></a>什么是像素</h4><p>每个图像都由一组像素组成。 像素是图像的原始构建块。没有比像素更小的单位了。</p><p>通常，我们将像素视为出现在图像中给定位置的光的“颜色”或“强度”。</p><p>如果我们将图像视为网格，则网格中的每个方块都包含一个像素。</p><p>例如，假设我们有一个分辨率为500×300的图像。这意味着我们的图像表示为像素网格，有500行和300列。总体而言，我们的图像总共有 500×300 = 150,000像素。</p><p>大多数像素以两种方式表示：灰度(grayscale)和彩色(color)。在灰度图像中，每个像素具有0到255之间的值，其中0对应于“黑色”而255对应于“白色”。 0到255之间的值是不同的灰色阴影，其中，接近0的更加的darker，接近于255更加的lighter。</p><p>彩色通常以RGB颜色空间表示，one value for the Red component,one for Green,and one for Blue。</p><p>RGB中的每一种都由0到255范围内的整数表示，这表示颜色的“多少”。像素值只需要在[0,255]范围内，我们通常使用8位无符号整数来表示每种颜色强度。</p><p>然后，我们将这些值组合成图形中的RGB(红色，绿色，蓝色）元组(tuple)。 这个元组就代表我们的颜色。</p><p>为了构建一个白色，我们将完全填充每个红色，绿色和蓝色 buckets，如下所示:(255,255,255）。为了创建一个黑色，我们将每个bucket都清空：(0,0,0) ，为了创造一种纯红色，我们将完全填满红色的bucket：(255,0,0）。</p><h4 id="coordinate-system-坐标系统"><a href="#coordinate-system-坐标系统" class="headerlink" title="coordinate system(坐标系统)"></a>coordinate system(坐标系统)</h4><p>如上所述，图像表示为像素网格。 想象一下我们的网格作为一张方格纸。 使用该方格纸，点(0,0）对应于图像的左上角。 当我们向下和向右移动时，x和y值都会增加。(Python语言是零索引的，这意味着我们总是从零开始计数。)，看下图：</p><center><img src="https://i.imgur.com/CIsf7wW.png" alt=""></center><center>字母“I”放在一张图纸上.像素是通过他们的(x，y）坐标访问的，我们向右走x列，向下走y行(因为x是横坐标，y是纵坐标)，记住Python是零索引的：我们从零而不是一开始计数。</center><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>from __future__ import print_functionimport argparseimport cv2 ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,        help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)</code></pre><p>请记住，OpenCV将图像表示为NumPy数组。概念上，我们可以将此表示视为一个矩阵。为了访问像素值，我们只需要提供我们感兴趣的像素的x和y坐标。但是，重要的是要注意<strong>OpenCV以相反的顺序存储RGB channels。 虽然我们通常用Red，Green和Blue(RGB)来思考，但OpenCV实际上按Blue，Green和Red的顺序存储它们(BGR)。</strong>如下面的代码：</p><pre><code>(b,g,r) = image[0,0]print(&quot;Pixel at (0,0) - Red:{}, Green： {}， Blue: {}&quot;.format(    r,g,b))image[0,0] = (0,0,255)(b,g,r) = image[0,0]print(&quot;Pixel at (0,0) - Red: {} , Green: {}, Blue: {}&quot;.format(r,    g,b))</code></pre><p><strong>解释</strong>：</p><p>我们首先抓取图像的左上角的像素，即(0,0)的位置。 这个像素表示为元组.同时，OpenCV以相反的顺序存储RGB像素，因此当我们解包并访问元组中的每个元素时，我们实际上是以BGR顺序查看它们。然后我们将像素RGB颜色打印出来。</p><p>接下来，我们操纵图像中的左上角像素，该像素位于坐标（0,0）处，并将其设置为(0,0,255)。 如果我们以RGB格式读取这个像素值，我们的红色值为0，绿色值为0，蓝色值为255，因此使其成为纯蓝色。但是，正如我上面提到的，在使用OpenCV时我们需要特别注意。 我们的像素实际上以BGR格式存储，而不是RGB格式。我们实际上将这个像素读为255为红色，0为绿色，0为蓝色，使其成为红色，而不是蓝色。</p><pre><code>corner = image[0:100,0:100]cv2.imshow(&quot;Corner&quot;,corner)image[0:100,0:100] = (0,255,0)cv2.imshow(&quot;Updated&quot;,image)cv2.waitKey(0)</code></pre><p><strong>解释</strong>：</p><p>接下来我们使用NumPy的数组切片功能来访问图像的较大矩形部分。为了访问图像较大的部分，Numpy希望我们提供四个索引值，分别是Start y,End y,Start x以及End x。 </p><p>最后，运行程序即可。</p><p><img src="https://i.imgur.com/cdnBl5U.png" alt=""></p><p>效果图：</p><p><img src="https://i.imgur.com/61ClxZk.png" alt=""></p><p>点击图片部分，按键盘任意键结束脚本。</p><p><strong>完整的代码</strong></p><pre><code>from __future__ import print_functionimport argparseimport cv2 ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,        help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;,image)(b,g,r) = image[0,0]print(&quot;Pixel at (0,0) - Red:{}, Green： {}， Blue: {}&quot;.format(    r,g,b))image[0,0] = (0,0,255)(b,g,r) = image[0,0]print(&quot;Pixel at (0,0) - Red: {} , Green: {}, Blue: {}&quot;.format(r,    g,b))corner = image[0:100,0:100]cv2.imshow(&quot;Corner&quot;,corner)image[0:100,0:100] = (0,255,0)cv2.imshow(&quot;Updated&quot;,image)cv2.waitKey(0)</code></pre><p><strong>用到的函数</strong></p><p><span id="inline-blue">imread</span></p><p><span id="inline-blue">imshow</span></p><p><span id="inline-blue">waitKey</span></p><h3 id="更多的参考："><a href="#更多的参考：" class="headerlink" title="更多的参考："></a>更多的参考：</h3><p><a href="https://ppao.pyimagesearch.com/lessons/ppao-chapter-4-image-basics/" target="_blank" rel="noopener">chapter-4-image-basics</a></p><p><a href="https://www.learnopencv.com/why-does-opencv-use-bgr-color-format/" target="_blank" rel="noopener">why-does-opencv-use-bgr-color-format</a></p><p>总结起来就是：</p><p>有一些技术原因，但总的来说，为什么开发人员选择BGR格式的原因是因为在BGR中指定颜色值而不是RGB在当时更受欢迎 - 这就是全部。</p><hr>]]></content>
    
    <summary type="html">
    
      第二个代码
    
    </summary>
    
      <category term="计算机视觉" scheme="https://0Leo0.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Oepncv" scheme="https://0Leo0.github.io/tags/Oepncv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV_python3_01</title>
    <link href="https://0Leo0.github.io//2018/OpenCV_python3_01.html"/>
    <id>https://0Leo0.github.io//2018/OpenCV_python3_01.html</id>
    <published>2018-11-08T11:17:57.000Z</published>
    <updated>2018-11-09T03:41:18.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="Practical-Python-and-OpenCV-3rd-Edition-01"><a href="#Practical-Python-and-OpenCV-3rd-Edition-01" class="headerlink" title="Practical Python and OpenCV,3rd Edition 01"></a>Practical Python and OpenCV,3rd Edition 01</h2><hr><h3 id="load、display、save"><a href="#load、display、save" class="headerlink" title="load、display、save"></a>load、display、save</h3><pre><code>from __future__ import print_functionimport argparseimport cv2 </code></pre><p><strong>解释</strong>：</p><p>  从<strong>future</strong> package中导入print_function，是因为我们将使用实际的print() function，而不是print statement，这样我们的代码就可以在python2.7以及python3中共同运行。</p><pre><code>ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,    help=&quot;Path to the image&quot;)args = vars(ap.parse_args())</code></pre><p><strong>解释</strong>：</p><p>  使用“–image”参数，也就是我们图像在磁盘的路径，我们将这个路径进行parse，然后将他们存储在一个字典中。</p><pre><code>image = cv2.imread(args[&quot;image&quot;])print(&quot;height: {} pixels&quot;.format(image.shape[0]))print(&quot;width : {} pixels&quot;.format(image.shape[1]))print(&quot;channels : {}&quot;.format(image.shape[2]))cv2.imshow(&quot;Image&quot;,image)cv2.waitKey(0)</code></pre><p><strong>解释</strong>：</p><p>  cv2.imread函数将返回一个Numpy数据，代表着图像。对于Numpy数组，我们可以使用shape属性来获取图像的width、height以及channels的数量。imshow函数将我们的图像显示在Windows窗口中，它的第一个参数是”name” of our window.第二个参数是我们从磁盘加载的图像了。而waitKey函数会暂停我们的脚本程序，直到我们在键盘上按下一个key之后才继续执行，而参数0则表示我们按键盘上的任意键都可以继续执行脚本程序。</p><pre><code>cv2.imwrite(&quot;newimage.jpg&quot;,image)</code></pre><p><strong>解释</strong>：</p><p>  最后我们使用imwrite函数将我们的保存为jpg格式的图像，第一个参数是我们要保存的图像的路径名，第二个是我们希望保存的图像。</p><p>最后执行脚本程序：</p><p><img src="https://i.imgur.com/wUmgT2H.png" alt=""></p><p>显示效果图片</p><p><img src="https://i.imgur.com/JO02dxm.png" alt=""></p><p>停止脚本程序很简单，就如前面所说的，在显示的图片的任意地方按键盘上的任意键即可。然后查看脚本目录，你可以看到一个newimage.jpg的图片</p><p><img src="https://i.imgur.com/whM20GA.png" alt=""></p><p><strong>完整的代码</strong></p><pre><code>from __future__ import print_functionimport argparseimport cv2 ap = argparse.ArgumentParser()ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True,    help=&quot;Path to the image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])print(&quot;height: {} pixels&quot;.format(image.shape[0]))print(&quot;width : {} pixels&quot;.format(image.shape[1]))print(&quot;channels : {}&quot;.format(image.shape[2]))cv2.imshow(&quot;Image&quot;,image)cv2.waitKey(0)cv2.imwrite(&quot;newimage.jpg&quot;,image)</code></pre><p><strong>用到的函数</strong></p><p><span id="inline-blue">imread</span></p><p><span id="inline-blue">imshow</span></p><p><span id="inline-blue">waitKey</span></p><p><span id="inline-blue">imwrite</span></p><div class="note danger no-icon"><p>danger no-icon</p></div><p>在上面的代码中，height对应于shape[0]，width对应于shape[1]。也就是Numpy 的shape似乎和自己想的不一样(specifying the height before the width)。但是，就matrix definition而言，这实际上是有意义。因为当我们定义矩阵的时候，我们通常将它们写成(# of rows x # of columns)的形式。这里，我们的图片有height：400 pixels(the number of rows) 以及 width：400 pixels(the number of columns).</p><h3 id="更多的参考："><a href="#更多的参考：" class="headerlink" title="更多的参考："></a>更多的参考：</h3><p><a href="https://ppao.pyimagesearch.com/lessons/ppao-chapter-3-loading-displaying-and-saving/" target="_blank" rel="noopener">loading-displaying-and-saving</a></p><p><a href="https://www.pyimagesearch.com/2014/06/02/opencv-load-image/" target="_blank" rel="noopener">How-To: OpenCV Load an Image</a></p><p><a href="https://www.cyberciti.biz/faq/python-command-line-arguments-argv-example/" target="_blank" rel="noopener">Python Command Line Arguments</a></p><p><a href="https://www.pyimagesearch.com/2014/11/03/display-matplotlib-rgb-image/" target="_blank" rel="noopener">How to Display a Matplotlib RGB Image</a></p><p><a href="https://www.pyimagesearch.com/2015/08/24/resolved-matplotlib-figures-not-showing-up-or-displaying/" target="_blank" rel="noopener">Resolved: Matplotlib figures not showing up or displaying</a></p><hr>]]></content>
    
    <summary type="html">
    
      第一个代码
    
    </summary>
    
      <category term="计算机视觉" scheme="https://0Leo0.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="https://0Leo0.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>git学习之路_2_文件管理</title>
    <link href="https://0Leo0.github.io//2018/git_2.html"/>
    <id>https://0Leo0.github.io//2018/git_2.html</id>
    <published>2018-10-29T04:17:57.000Z</published>
    <updated>2018-11-04T12:26:15.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="时光穿梭"><a href="#时光穿梭" class="headerlink" title="时光穿梭"></a>时光穿梭</h2><p>前面我们已经添加并提交了一个readme.txt文件，现在我们将文件进行修改，改为下面的内容：</p><p><img src="https://s1.ax1x.com/2018/11/04/i5oLX8.png" alt="修改readme.txt"></p><p>现在，我们运行命令<code>git status</code>看一看会有什么结果：</p><p><img src="https://s1.ax1x.com/2018/11/04/i5oTfI.png" alt="运行git status命令"></p><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，从上图中可以看出来，redme.txt文件显然被修改过了，但是我们并没有准备提交我们的修改。如果我们不知道修改了什么样的内容，我们可以运行命令<code>git diff</code>来查看具体修改了什么样的内容。</p><p><img src="https://s1.ax1x.com/2018/11/04/i5oHpt.png" alt="运行git diff命令"></p><p>diff是英文difference的缩写，上图中显示的格式是Unix通用的diff格式，知道了我们对readme.txt文件做了那些修改，接下来我们把文件提交到仓库中，一样是两个步骤，第一步运行命令<code>git add</code></p><pre><code>git add readme.txt </code></pre><p>接下来在执行<code>git commit</code>命令之前，我们用命令<code>git status</code>看看当前仓库的状态</p><p><img src="https://s1.ax1x.com/2018/11/04/i5ootA.png" alt="运行git status命令"></p><p>上面的<code>git status</code>命令告诉我们，将要被提交的修改包括readme.txt，接下来，我们可以放心的提交了：</p><p><img src="https://s1.ax1x.com/2018/11/04/i5oq6f.png" alt="运行git commit命令"></p><p>进行了提交之后，我们再用<code>git status</code>命令来查看仓库的当前状态</p><p><img src="https://s1.ax1x.com/2018/11/04/i5ob1P.png" alt="运行git commit命令"></p><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净的(working tree clean)</p><p><span id="inline-blue">本节命令</span></p><p><code>git status</code>：掌握工作区的状态</p><p>‘<code>git diff</code>：查看修改的内容</p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743858312764dca7ad6d0754f76aa562e3789478044000" target="_blank" rel="noopener">Git 时光穿梭 </a></p><p><a href="https://www.git-tower.com/blog/git-cheat-sheet/" target="_blank" rel="noopener">Git cheat sheet英文版</a></p><p><a href="https://www.kancloud.cn/thinkphp/git-cheat-sheet/39651" target="_blank" rel="noopener">Git cheat sheet中文版</a></p><hr>]]></content>
    
    <summary type="html">
    
      git学习之时光穿梭
    
    </summary>
    
      <category term="git" scheme="https://0Leo0.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://0Leo0.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git学习之路_1_安装git以及创建版本库</title>
    <link href="https://0Leo0.github.io//2018/git_1.html"/>
    <id>https://0Leo0.github.io//2018/git_1.html</id>
    <published>2018-10-28T08:17:57.000Z</published>
    <updated>2018-10-29T04:11:00.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="windows上安装Git"><a href="#windows上安装Git" class="headerlink" title="windows上安装Git"></a>windows上安装Git</h2><p>下载git for windows，新手默认安装即可。</p><p>官方网址为：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p><p>安装完成之后，下一步就应该告诉git你来自哪里。因为Git是分布式版本控制系统，所以每个机器必须自报家门，即告诉git，你的名字和Email地址，命令为：</p><pre><code>git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot;</code></pre><p>注意：(引号内请输入你自己设置的名字和自己的邮箱),此用户名和邮箱是git提交代码时用来显示你的身份和联系方式的，并不是github用户名和邮箱。其中<code>--global</code>参数表示你这台及其上所有的git仓库都会使用这个配置。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>在Windows系统上，为了避免各种莫名其妙的问题，请确保目录名(不管是子目录还是父目录)不要包含中文。</p><p>之后使用命令<code>git init</code>来将这个目录变成Git可以管理的仓库。<br><img src="https://s1.ax1x.com/2018/10/28/icvY1f.png" alt="初始化仓库"></p><p>Git仓库建好了，还是一个空的仓库，同时在该目录下会有一个隐藏的<code>.git</code>目录，这个目录是用来跟踪管理版本库的，没事千万别修改哦！</p><ul><li>把文件添加到版本库中</li></ul><p>首先是文本编辑器的编码问题，强烈推荐使用UTF-8编码，而在Windows上不用使用Windows自带的<strong>记事本</strong>，可以选择notepad++，将默认编码改为：UTF-8 without BOM即可<br><img src="https://s1.ax1x.com/2018/10/28/icvBAs.png" alt="编码"></p><p>让我们来新建一个readme.txt文件，输入下面的内容，<br><img src="https://s1.ax1x.com/2018/10/28/icvw7j.png" alt="readme.txt"></p><p><strong>注意</strong>：这个文件一定要放在init的目录(或者子目录也行)下(否则git不能管理)，接着，把这个文件放到git仓库中只需要两步即可。</p><ol><li><p>用<code>git add</code>告诉Git，把该文件添加到仓库中 </p><p> git add readme.txt </p></li><li><p>用<code>git commit</code>告诉Git，把文件提交到仓库中 </p><p> git commit -m “wrote a readme file”</p></li></ol><p>上述命令的<code>-m</code>表示本次提交的说明(comment),可以输入任何内容，有意义最好，这样你就可以从历史记录里面方便地找到改动的记录。<br><img src="https://s1.ax1x.com/2018/10/28/icvdBQ.png" alt="提交"></p><p>在执行完<code>git commit</code>命令之后，就会告诉你，<font color="red">1 file changed</font>:1个文件被改动(我们添加了readme.txt)；<font color="red">2 insertions</font>：插入了两行内容(readme.txt有两行内容)</p><p><span id="inline-blue">小贴士</span></p><p>为什么Git添加问价需要先add，再commit呢？因为commit命令可以一次提交很多文件(将add进去的文件都提交上去)，所以你可以多次add不同的文件。</p><p>比如：</p><pre><code>git add file1.txt file2.txtgit commit -m &quot;add 2 files&quot;</code></pre><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="noopener">Git 简介</a></p><p><a href="https://www.git-tower.com/blog/git-cheat-sheet/" target="_blank" rel="noopener">Git cheat sheet英文版</a></p><p><a href="https://www.kancloud.cn/thinkphp/git-cheat-sheet/39651" target="_blank" rel="noopener">Git cheat sheet中文版</a></p><hr>]]></content>
    
    <summary type="html">
    
      开启git学习之路
    
    </summary>
    
      <category term="git" scheme="https://0Leo0.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://0Leo0.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法学习</title>
    <link href="https://0Leo0.github.io//2018/Markdown%20grammar.html"/>
    <id>https://0Leo0.github.io//2018/Markdown grammar.html</id>
    <published>2018-10-26T11:17:57.000Z</published>
    <updated>2018-10-27T17:04:22.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p class="description"></p><a id="more"></a><h2 id="欢迎使用MarkdownPad编辑阅读器"><a href="#欢迎使用MarkdownPad编辑阅读器" class="headerlink" title="欢迎使用MarkdownPad编辑阅读器"></a>欢迎使用MarkdownPad编辑阅读器</h2><hr><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>使用 一对<code>*</code> 或者 <code>_</code> 表示包围的字体斜体显示<br>而一对<code>**</code> 或者<code>__</code> 来表示粗体。</p><p>例如：</p><pre><code>*你好，世界***你好，世界**</code></pre><p>显示效果为：</p><p><em>你好，世界</em></p><p><strong>你好，世界</strong></p><h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><p>Markdown 的标题有Setext和Atx两种语法形式，在Setex中，在文本下面标注<code>=</code>表示最高级标题，在下面标注<code>-</code>表示第二级标题，比如下面的Setext形式输出一级标题和二级标题</p><pre><code>Headline 1==========Headline 2--</code></pre><p>当然也可以使用Atx形式输出各级标题</p><pre><code>#Headline 1 ##Headline 2</code></pre><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>Markdown中使用空白行来分割段落，比如下面两端文本，只需要在两端之间加上一行空行，Markdown就会为文本分段</p><pre><code>Hello world 我是空白行  你好啊世界</code></pre><p>显示效果为：</p><p>Hello world </p><p>你好啊世界</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown支持HTML嵌套，我们可以利用HTML标记实现更改颜色的需求，更改颜色代码如下：</p><pre><code>Default Color&lt;font color=&apos;red&apos;&gt;Red Color&lt;/font&gt;&lt;font color=&apos;blue&apos;&gt;Blue Color&lt;/font&gt;&lt;font color=&apos;green&apos;&gt;Green Color&lt;/font&gt;&lt;font color=&apos;yellow&apos;&gt;Yellow Color&lt;/font&gt;&lt;font color=&apos;pink&apos;&gt;Pink Color&lt;/font&gt;&lt;font color=&apos;purple&apos;&gt;Purple Color&lt;/font&gt;&lt;font color=&apos;orange&apos;&gt;Orange Color&lt;/font&gt;</code></pre><p>显示效果为：</p><font color="red">Red Color</font><font color="blue">Blue Color</font><font color="green">Green Color</font><font color="yellow">Yellow Color</font><font color="pink">Pink Color</font><font color="purple">Purple Color</font><font color="orange">Orange Color</font><p>更改字号、字体也可以使用HTML轻松实现</p><pre><code>&lt;font size=&apos;-2&apos;&gt;Small Size&lt;/font&gt;Normal Size&lt;font size=&apos;+2&apos;&gt;Big Size&lt;/font&gt;&lt;font size=&apos;+2&apos; face=&apos;楷体&apos;&gt;楷体&lt;/font&gt;</code></pre><p>输出显示为：</p><font size="-2">Small Size</font><p>Normal Size</p><font size="+2">Big Size</font><font size="+2" face="楷体">楷体</font><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Markdown使用email的区块引用方式，即右尖括号<code>&gt;</code>后面跟引用的内容，如下</p><pre><code>&gt;Hello World&gt;你好，世界</code></pre><p>其输出为：</p><blockquote><p>Hello World </p></blockquote><blockquote><p>你好，世界</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown中使用型号<code>*</code> , 加号<code>+</code> 以及减号<code>-</code> 来表示无序列表(中间有空格)</p><pre><code>* 我是列表+ 我也是列表- 我还是列表</code></pre><p>其输出为：</p><ul><li>我是列表</li></ul><ul><li>我也是列表</li></ul><ul><li>我还是列表</li></ul><p>有序列表使用一个数字加一个英文句点作为项目标记，比如</p><pre><code>1. 我是列表2. 我也是列表</code></pre><p>其输出如下：</p><ol><li><p>我是列表</p></li><li><p>我也是列表</p></li></ol><p>同时，列表也是可以进行嵌套使用的(中间不用空格)，比如：</p><pre><code>1.你好，世界&gt;你好，世界2.Hello World&gt;Hello World</code></pre><p>输出结果为：</p><p>1.你好，世界</p><blockquote><p>你好，世界</p></blockquote><p>2.Hello World</p><blockquote><p>Hello World</p></blockquote><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown支持行内和参考两种形式的链接语法，两种都是使用中括号来把文字转成链接，行内形式是中括号包围文字，后面紧跟圆括号包围的链接，其代码如下所示：</p><pre><code>[我的博客](https://0leo0.github.io/)</code></pre><p>其输出为：</p><p><a href="https://0leo0.github.io/">我的博客</a></p><p>当然，我们也可以给我们的链接加上一个title属性，</p><pre><code>[我的博客](https://0leo0.github.io/ &quot;我是一个标题&quot;)</code></pre><p>输出如下：</p><p><a href="https://0leo0.github.io/" title="我是一个标题">我的博客</a></p><p>参考形式的链接可以在原文中为链接定义一个名称，然后在文章的其他地方定义该链接的内容，其语法格式为 <code>[链接文本][链接名称]</code> </p><pre><code>我想搜索关于Python的内容，可以去[Google][1],以及[Yahoo][2]和[Baidu][3]</code></pre><p>然后在别的地方定义链接内容，语法格式为<code>[链接名称]:空白符 URL &quot;title&quot;</code></p><pre><code>[1]: https://google.com/ &quot;Google&quot;[2]: https://yahoo.com/ &quot;Yahoo&quot;[3]: https://baidu.com/ &quot;Baidu&quot;</code></pre><p>显示效果为：</p><p>我想搜索关于Python的内容，可以去<a href="https://google.com/" title="Google" target="_blank" rel="noopener">Google</a>,以及<a href="https://yahoo.com/" title="Yahoo" target="_blank" rel="noopener">Yahoo</a>和<a href="https://baidu.com/" title="Baidu" target="_blank" rel="noopener">Baidu</a></p><p>另外，使用<code>&lt;&gt;</code> 包括的URL或者邮箱地址会被自动转换为超链接</p><pre><code>&lt;https://0leo0.github.io/&gt;&lt;wen_9407@yahoo.com&gt;</code></pre><p>效果如下：</p><p><a href="https://0leo0.github.io/">https://0leo0.github.io/</a></p><p><a href="mailto:&#x77;&#x65;&#x6e;&#x5f;&#x39;&#52;&#x30;&#x37;&#x40;&#121;&#x61;&#x68;&#111;&#x6f;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x77;&#x65;&#x6e;&#x5f;&#x39;&#52;&#x30;&#x37;&#x40;&#121;&#x61;&#x68;&#111;&#x6f;&#46;&#x63;&#x6f;&#109;</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片的语法格式和链接类似，也分为行内形式和参考形式。</p><p>行内形式语法格式为：<code>![alt text](URL title)</code>,其中alt,text以及text都可以选择性的加入，但URL必须有</p><pre><code>![我要显示图片](https://imgchr.com/i/iy5Th9)</code></pre><p>显示的效果如下：</p><p><img src="https://s1.ax1x.com/2018/10/26/iy5Th9.jpg" alt="我要显示图片" title="海贼王"></p><p>参考形式分为两部分，声明图片链接名称和定义图片链接</p><p>其中声明图片链接语法格式为：<code>![alt text][id]</code></p><p>定义图片链接内容的语法格式为： <code>[id]:URL &quot;title&quot;</code>.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在一般段落文字中，可以使用反引号`来标记代码区段。</p><pre><code>我喜欢这个世界`&lt;blank&gt;`，哈哈</code></pre><p>显示效果</p><p>我喜欢这个世界<code>&lt;blank&gt;</code>，哈哈</p><p>在Markdown中，如果行开头有4个空格，将被视为代码。但是这种方式，不推荐，我们推荐的方式是代码块的首行用3个反引号`和编程语言名称(C、Python等)标记代码块开始，代码块的结尾用3个反引号来闭合代码块。</p><p>比如，将一段python代码插入到Markdown，首行用3个反引号来标记代码块，最后一行再用3个反引号来闭合代码块。</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"calculate X to the power of Y"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'square'</span>,type=int,\</span><br><span class="line">        help=<span class="string">"display a square of a given number"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-v'</span>,<span class="string">"--verbosity"</span>,type=int,choices=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],\</span><br><span class="line">        default=<span class="number">1</span>,help=<span class="string">"increase output verbosity"</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">answer = args.square ** <span class="number">2</span></span><br></pre></td></tr></table></figure></code></pre><p>那么其显示效果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">"calculate X to the power of Y"</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'square'</span>,type=int,\</span><br><span class="line">        help=<span class="string">"display a square of a given number"</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-v'</span>,<span class="string">"--verbosity"</span>,type=int,choices=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],\</span><br><span class="line">        default=<span class="number">1</span>,help=<span class="string">"increase output verbosity"</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">answer = args.square ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>考虑HTML和CSS<br>(使用列表的话，下面的会显示出作用，而不是以代码的形式显示出来)</p><p>1.分割线和空行</p><pre><code>/*分割线*/&lt;hr /&gt;/*空行*/&lt;br /&gt;</code></pre><p>2.引用</p><pre><code>&lt;blockquote&gt;引用内容&lt;/blockquote&gt;/*如果上下间距很小，可以加个P*/&lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt;</code></pre><p>3.居中与右对齐</p><pre><code>/*居中*/&lt;center&gt;内容&lt;/center&gt;/*右对齐*/&lt;p style=&quot;text-align:right&quot;&gt;内容&lt;/p&gt;</code></pre><p>4.字体大小和颜色</p><pre><code>&lt;font colr=&quot;#xxxxxx&quot; size=&quot;numbr&quot;&gt;内容&lt;/font&gt;//详细请查看W3schcool：https://www.w3school.com.cn/tags/tag_font.asp</code></pre><p>5.Todo list</p><pre><code>&lt;ul&gt;&lt;li&gt;&lt;i class=&quot;fa fa-check-square&quot;&gt;&lt;/i&gt;已完成&lt;/li&gt;&lt;li&gt;&lt;i class=&quot;fa fasquare&quot;&gt;&lt;/i&gt;未完成&lt;/li&gt;&lt;/ul&gt;</code></pre><h2 id="Markdown-高阶语法"><a href="#Markdown-高阶语法" class="headerlink" title="Markdown 高阶语法"></a>Markdown 高阶语法</h2><h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><p>在段落中填写[TOC]以显示全文内容的目录结构</p><p>[TOC]</p><h3 id="标签分类"><a href="#标签分类" class="headerlink" title="标签分类"></a>标签分类</h3><p>在编辑区任意行的的列首位置输入以下代码给文稿标签： </p><p>标签: 数学 英语 Markdown</p><p>或者</p><p>Tags: 数学 英语 Markdown</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>使用~~ 表示删除线。</p><p>~~ 这是一段错误的文本 ~~</p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>使用[^keyword]表示脚注</p><p>这是一个脚注<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的样例</p><h3 id="LaTex公式"><a href="#LaTex公式" class="headerlink" title="LaTex公式"></a>LaTex公式</h3><p>$表示行内公式</p><p>质能守恒方程 $E=mc<sup>2</sup></p><p>这里的上标我使用sup / sup，用四个尖括号括起来，同样下标为sub</p><p>而$$表示整行公式，具体参考<a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a></p><hr><h3 id="参考网址："><a href="#参考网址：" class="headerlink" title="参考网址："></a>参考网址：</h3><p><a href="https://www.zybuluo.com/static/editor/cmd-manual.html" target="_blank" rel="noopener">Cmd Markdown简明语法手册</a></p><p><a href="https://www.cnblogs.com/dezheng/p/3834813.html" target="_blank" rel="noopener">Markdown入门基础</a></p><p><a href="https://fontawesome.com/v4.7.0/examples/" target="_blank" rel="noopener">fontawesome</a></p><p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">reuixiy</a></p><p><span id="inline-blue">后话</span></p><p>第一篇markdown写的文章弄的我好辛苦，主要是用markdownpad编辑好的和hexo解析出的html不一样，在网页上看到的不是自己想要的，后面希望会好一点吧！！</p><hr>]]></content>
    
    <summary type="html">
    
      什么？你竟然还不会用markdown？
    
    </summary>
    
      <category term="markdown" scheme="https://0Leo0.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="https://0Leo0.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
