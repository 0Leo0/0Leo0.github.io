<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenCV_python3_01]]></title>
    <url>%2F%2F2018%2FOpenCV_python3.html</url>
    <content type="text"><![CDATA[Practical Python and OpenCV,3rd Edition 01 load、display、savefrom __future__ import print_function import argparse import cv2 解释： 从future package中导入print_function，是因为我们将使用实际的print() function，而不是print statement，这样我们的代码就可以在python2.7以及python3中共同运行。 ap = argparse.ArgumentParser() ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True, help=&quot;Path to the image&quot;) args = vars(ap.parse_args()) 解释： 使用“–image”参数，也就是我们图像在磁盘的路径，我们将这个路径进行parse，然后将他们存储在一个字典中。 image = cv2.imread(args[&quot;image&quot;]) print(&quot;height: {} pixels&quot;.format(image.shape[0])) print(&quot;width : {} pixels&quot;.format(image.shape[1])) print(&quot;channels : {}&quot;.format(image.shape[2])) cv2.imshow(&quot;Image&quot;,image) cv2.waitKey(0) 解释： cv2.imread函数将返回一个Numpy数据，代表着图像。对于Numpy数组，我们可以使用shape属性来获取图像的width、height以及channels的数量。imshow函数将我们的图像显示在Windows窗口中，它的第一个参数是”name” of our window.第二个参数是我们从磁盘加载的图像了。而waitKey函数会暂停我们的脚本程序，直到我们在键盘上按下一个key之后才继续执行，而参数0则表示我们按键盘上的任意键都可以继续执行脚本程序。 cv2.imwrite(&quot;newimage.jpg&quot;,image) 解释： 最后我们使用imwrite函数将我们的保存为jpg格式的图像，第一个参数是我们要保存的图像的路径名，第二个是我们希望保存的图像。 最后执行脚本程序： 显示效果图片 停止脚本程序很简单，就如前面所说的，在显示的图片的任意地方按键盘上的任意键即可。然后查看脚本目录，你可以看到一个newimage.jpg的图片 完整的代码 from __future__ import print_function import argparse import cv2 ap = argparse.ArgumentParser() ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True, help=&quot;Path to the image&quot;) args = vars(ap.parse_args()) image = cv2.imread(args[&quot;image&quot;]) print(&quot;height: {} pixels&quot;.format(image.shape[0])) print(&quot;width : {} pixels&quot;.format(image.shape[1])) print(&quot;channels : {}&quot;.format(image.shape[2])) cv2.imshow(&quot;Image&quot;,image) cv2.waitKey(0) cv2.imwrite(&quot;newimage.jpg&quot;,image) 用到的函数 imread imshow waitKey imwrite danger no-icon 在上面的代码中，height对应于shape[0]，width对应于shape[1]。也就是Numpy 的shape似乎和自己想的不一样(specifying the height before the width)。但是，就matrix definition而言，这实际上是有意义。因为当我们定义矩阵的时候，我们通常将它们写成(# of rows x # of columns)的形式。这里，我们的图片有height：400 pixels(the number of rows) 以及 width：400 pixels(the number of columns). 更多的参考：loading-displaying-and-saving How-To: OpenCV Load an Image Python Command Line Arguments How to Display a Matplotlib RGB Image Resolved: Matplotlib figures not showing up or displaying]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV_python3_01]]></title>
    <url>%2F%2F2018%2FOpenCV_python3.html</url>
    <content type="text"><![CDATA[Practical Python and OpenCV,3rd Edition 02 基础说明什么是像素每个图像都由一组像素组成。 像素是图像的原始构建块。没有比像素更小的单位了。 通常，我们将像素视为出现在图像中给定位置的光的“颜色”或“强度”。 如果我们将图像视为网格，则网格中的每个方块都包含一个像素。 例如，假设我们有一个分辨率为500×300的图像。这意味着我们的图像表示为像素网格，有500行和300列。总体而言，我们的图像总共有 500×300 = 150,000像素。 大多数像素以两种方式表示：灰度(grayscale)和彩色(color)。在灰度图像中，每个像素具有0到255之间的值，其中0对应于“黑色”而255对应于“白色”。 0到255之间的值是不同的灰色阴影，其中，接近0的更加的darker，接近于255更加的lighter。 彩色通常以RGB颜色空间表示，one value for the Red component,one for Green,and one for Blue。 RGB中的每一种都由0到255范围内的整数表示，这表示颜色的“多少”。像素值只需要在[0,255]范围内，我们通常使用8位无符号整数来表示每种颜色强度。 然后，我们将这些值组合成图形中的RGB(红色，绿色，蓝色）元组(tuple)。 这个元组就代表我们的颜色。 为了构建一个白色，我们将完全填充每个红色，绿色和蓝色 buckets，如下所示:(255,255,255）。为了创建一个黑色，我们将每个bucket都清空：(0,0,0) ，为了创造一种纯红色，我们将完全填满红色的bucket：(255,0,0）。 coordinate system(坐标系统)如上所述，图像表示为像素网格。 想象一下我们的网格作为一张方格纸。 使用该方格纸，点(0,0）对应于图像的左上角。 当我们向下和向右移动时，x和y值都会增加。(Python语言是零索引的，这意味着我们总是从零开始计数。)，看下图： 字母“I”放在一张图纸上.像素是通过他们的(x，y）坐标访问的，我们向右走x列，向下走y行(因为x是横坐标，y是纵坐标)，记住Python是零索引的：我们从零而不是一开始计数。 代码from __future__ import print_function import argparse import cv2 ap = argparse.ArgumentParser() ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True, help=&quot;Path to the image&quot;) args = vars(ap.parse_args()) image = cv2.imread(args[&quot;image&quot;]) cv2.imshow(&quot;Original&quot;,image) 请记住，OpenCV将图像表示为NumPy数组。概念上，我们可以将此表示视为一个矩阵。为了访问像素值，我们只需要提供我们感兴趣的像素的x和y坐标。但是，重要的是要注意OpenCV以相反的顺序存储RGB channels。 虽然我们通常用Red，Green和Blue(RGB)来思考，但OpenCV实际上按Blue，Green和Red的顺序存储它们(BGR)。如下面的代码： (b,g,r) = image[0,0] print(&quot;Pixel at (0,0) - Red:{}, Green： {}， Blue: {}&quot;.format( r,g,b)) image[0,0] = (0,0,255) (b,g,r) = image[0,0] print(&quot;Pixel at (0,0) - Red: {} , Green: {}, Blue: {}&quot;.format(r, g,b)) 解释： 我们首先抓取图像的左上角的像素，即(0,0)的位置。 这个像素表示为元组.同时，OpenCV以相反的顺序存储RGB像素，因此当我们解包并访问元组中的每个元素时，我们实际上是以BGR顺序查看它们。然后我们将像素RGB颜色打印出来。 接下来，我们操纵图像中的左上角像素，该像素位于坐标（0,0）处，并将其设置为(0,0,255)。 如果我们以RGB格式读取这个像素值，我们的红色值为0，绿色值为0，蓝色值为255，因此使其成为纯蓝色。但是，正如我上面提到的，在使用OpenCV时我们需要特别注意。 我们的像素实际上以BGR格式存储，而不是RGB格式。我们实际上将这个像素读为255为红色，0为绿色，0为蓝色，使其成为红色，而不是蓝色。 corner = image[0:100,0:100] cv2.imshow(&quot;Corner&quot;,corner) image[0:100,0:100] = (0,255,0) cv2.imshow(&quot;Updated&quot;,image) cv2.waitKey(0) 解释： 接下来我们使用NumPy的数组切片功能来访问图像的较大矩形部分。为了访问图像较大的部分，Numpy希望我们提供四个索引值，分别是Start y,End y,Start x以及End x。 最后，运行程序即可。 效果图： 点击图片部分，按键盘任意键结束脚本。 完整的代码 from __future__ import print_function import argparse import cv2 ap = argparse.ArgumentParser() ap.add_argument(&apos;-i&apos;,&quot;--image&quot;,required=True, help=&quot;Path to the image&quot;) args = vars(ap.parse_args()) image = cv2.imread(args[&quot;image&quot;]) cv2.imshow(&quot;Original&quot;,image) (b,g,r) = image[0,0] print(&quot;Pixel at (0,0) - Red:{}, Green： {}， Blue: {}&quot;.format( r,g,b)) image[0,0] = (0,0,255) (b,g,r) = image[0,0] print(&quot;Pixel at (0,0) - Red: {} , Green: {}, Blue: {}&quot;.format(r, g,b)) corner = image[0:100,0:100] cv2.imshow(&quot;Corner&quot;,corner) image[0:100,0:100] = (0,255,0) cv2.imshow(&quot;Updated&quot;,image) cv2.waitKey(0) 用到的函数 imread imshow waitKey 更多的参考：chapter-4-image-basics why-does-opencv-use-bgr-color-format 总结起来就是： 有一些技术原因，但总的来说，为什么开发人员选择BGR格式的原因是因为在BGR中指定颜色值而不是RGB在当时更受欢迎 - 这就是全部。]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>Oepncv Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习之路_2_文件管理]]></title>
    <url>%2F%2F2018%2Fgit_2.html</url>
    <content type="text"><![CDATA[时光穿梭前面我们已经添加并提交了一个readme.txt文件，现在我们将文件进行修改，改为下面的内容： 现在，我们运行命令git status看一看会有什么结果： git status命令可以让我们时刻掌握仓库当前的状态，从上图中可以看出来，redme.txt文件显然被修改过了，但是我们并没有准备提交我们的修改。如果我们不知道修改了什么样的内容，我们可以运行命令git diff来查看具体修改了什么样的内容。 diff是英文difference的缩写，上图中显示的格式是Unix通用的diff格式，知道了我们对readme.txt文件做了那些修改，接下来我们把文件提交到仓库中，一样是两个步骤，第一步运行命令git add git add readme.txt 接下来在执行git commit命令之前，我们用命令git status看看当前仓库的状态 上面的git status命令告诉我们，将要被提交的修改包括readme.txt，接下来，我们可以放心的提交了： 进行了提交之后，我们再用git status命令来查看仓库的当前状态 Git告诉我们当前没有需要提交的修改，而且，工作目录是干净的(working tree clean) 本节命令 git status：掌握工作区的状态 ‘git diff：查看修改的内容 参考来源Git 时光穿梭 Git cheat sheet英文版 Git cheat sheet中文版]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习之路_1_安装git以及创建版本库]]></title>
    <url>%2F%2F2018%2Fgit_1.html</url>
    <content type="text"><![CDATA[windows上安装Git下载git for windows，新手默认安装即可。 官方网址为：https://gitforwindows.org/ 安装完成之后，下一步就应该告诉git你来自哪里。因为Git是分布式版本控制系统，所以每个机器必须自报家门，即告诉git，你的名字和Email地址，命令为： git config --global user.name &quot;your name&quot; git config --global user.email &quot;your email&quot; 注意：(引号内请输入你自己设置的名字和自己的邮箱),此用户名和邮箱是git提交代码时用来显示你的身份和联系方式的，并不是github用户名和邮箱。其中--global参数表示你这台及其上所有的git仓库都会使用这个配置。 创建版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 在Windows系统上，为了避免各种莫名其妙的问题，请确保目录名(不管是子目录还是父目录)不要包含中文。 之后使用命令git init来将这个目录变成Git可以管理的仓库。 Git仓库建好了，还是一个空的仓库，同时在该目录下会有一个隐藏的.git目录，这个目录是用来跟踪管理版本库的，没事千万别修改哦！ 把文件添加到版本库中 首先是文本编辑器的编码问题，强烈推荐使用UTF-8编码，而在Windows上不用使用Windows自带的记事本，可以选择notepad++，将默认编码改为：UTF-8 without BOM即可 让我们来新建一个readme.txt文件，输入下面的内容， 注意：这个文件一定要放在init的目录(或者子目录也行)下(否则git不能管理)，接着，把这个文件放到git仓库中只需要两步即可。 用git add告诉Git，把该文件添加到仓库中 git add readme.txt 用git commit告诉Git，把文件提交到仓库中 git commit -m “wrote a readme file” 上述命令的-m表示本次提交的说明(comment),可以输入任何内容，有意义最好，这样你就可以从历史记录里面方便地找到改动的记录。 在执行完git commit命令之后，就会告诉你，1 file changed:1个文件被改动(我们添加了readme.txt)；2 insertions：插入了两行内容(readme.txt有两行内容) 小贴士 为什么Git添加问价需要先add，再commit呢？因为commit命令可以一次提交很多文件(将add进去的文件都提交上去)，所以你可以多次add不同的文件。 比如： git add file1.txt file2.txt git commit -m &quot;add 2 files&quot; 参考来源Git 简介 Git cheat sheet英文版 Git cheat sheet中文版]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法学习]]></title>
    <url>%2F%2F2018%2FMarkdown%20grammar.html</url>
    <content type="text"><![CDATA[欢迎使用MarkdownPad编辑阅读器 粗体和斜体使用 一对* 或者 _ 表示包围的字体斜体显示而一对** 或者__ 来表示粗体。 例如： *你好，世界* **你好，世界** 显示效果为： 你好，世界 你好，世界 分级标题Markdown 的标题有Setext和Atx两种语法形式，在Setex中，在文本下面标注=表示最高级标题，在下面标注-表示第二级标题，比如下面的Setext形式输出一级标题和二级标题 Headline 1 ========== Headline 2 -- 当然也可以使用Atx形式输出各级标题 #Headline 1 ##Headline 2 段落Markdown中使用空白行来分割段落，比如下面两端文本，只需要在两端之间加上一行空行，Markdown就会为文本分段 Hello world 我是空白行 你好啊世界 显示效果为： Hello world 你好啊世界 字体Markdown支持HTML嵌套，我们可以利用HTML标记实现更改颜色的需求，更改颜色代码如下： Default Color &lt;font color=&apos;red&apos;&gt;Red Color&lt;/font&gt; &lt;font color=&apos;blue&apos;&gt;Blue Color&lt;/font&gt; &lt;font color=&apos;green&apos;&gt;Green Color&lt;/font&gt; &lt;font color=&apos;yellow&apos;&gt;Yellow Color&lt;/font&gt; &lt;font color=&apos;pink&apos;&gt;Pink Color&lt;/font&gt; &lt;font color=&apos;purple&apos;&gt;Purple Color&lt;/font&gt; &lt;font color=&apos;orange&apos;&gt;Orange Color&lt;/font&gt; 显示效果为： Red Color Blue Color Green Color Yellow Color Pink Color Purple Color Orange Color 更改字号、字体也可以使用HTML轻松实现 &lt;font size=&apos;-2&apos;&gt;Small Size&lt;/font&gt; Normal Size &lt;font size=&apos;+2&apos;&gt;Big Size&lt;/font&gt; &lt;font size=&apos;+2&apos; face=&apos;楷体&apos;&gt;楷体&lt;/font&gt; 输出显示为： Small Size Normal Size Big Size 楷体 引用Markdown使用email的区块引用方式，即右尖括号&gt;后面跟引用的内容，如下 &gt;Hello World &gt;你好，世界 其输出为： Hello World 你好，世界 列表Markdown中使用型号* , 加号+ 以及减号- 来表示无序列表(中间有空格) * 我是列表 + 我也是列表 - 我还是列表 其输出为： 我是列表 我也是列表 我还是列表 有序列表使用一个数字加一个英文句点作为项目标记，比如 1. 我是列表 2. 我也是列表 其输出如下： 我是列表 我也是列表 同时，列表也是可以进行嵌套使用的(中间不用空格)，比如： 1.你好，世界 &gt;你好，世界 2.Hello World &gt;Hello World 输出结果为： 1.你好，世界 你好，世界 2.Hello World Hello World 链接Markdown支持行内和参考两种形式的链接语法，两种都是使用中括号来把文字转成链接，行内形式是中括号包围文字，后面紧跟圆括号包围的链接，其代码如下所示： [我的博客](https://0leo0.github.io/) 其输出为： 我的博客 当然，我们也可以给我们的链接加上一个title属性， [我的博客](https://0leo0.github.io/ &quot;我是一个标题&quot;) 输出如下： 我的博客 参考形式的链接可以在原文中为链接定义一个名称，然后在文章的其他地方定义该链接的内容，其语法格式为 [链接文本][链接名称] 我想搜索关于Python的内容，可以去[Google][1],以及[Yahoo][2]和[Baidu][3] 然后在别的地方定义链接内容，语法格式为[链接名称]:空白符 URL &quot;title&quot; [1]: https://google.com/ &quot;Google&quot; [2]: https://yahoo.com/ &quot;Yahoo&quot; [3]: https://baidu.com/ &quot;Baidu&quot; 显示效果为： 我想搜索关于Python的内容，可以去Google,以及Yahoo和Baidu 另外，使用&lt;&gt; 包括的URL或者邮箱地址会被自动转换为超链接 &lt;https://0leo0.github.io/&gt; &lt;wen_9407@yahoo.com&gt; 效果如下： https://0leo0.github.io/ &#x77;&#101;&#110;&#95;&#57;&#x34;&#48;&#x37;&#64;&#121;&#97;&#x68;&#111;&#111;&#46;&#x63;&#x6f;&#x6d; 图片图片的语法格式和链接类似，也分为行内形式和参考形式。 行内形式语法格式为：![alt text](URL title),其中alt,text以及text都可以选择性的加入，但URL必须有 ![我要显示图片](https://imgchr.com/i/iy5Th9) 显示的效果如下： 参考形式分为两部分，声明图片链接名称和定义图片链接 其中声明图片链接语法格式为：![alt text][id] 定义图片链接内容的语法格式为： [id]:URL &quot;title&quot;. 代码在一般段落文字中，可以使用反引号`来标记代码区段。 我喜欢这个世界`&lt;blank&gt;`，哈哈 显示效果 我喜欢这个世界&lt;blank&gt;，哈哈 在Markdown中，如果行开头有4个空格，将被视为代码。但是这种方式，不推荐，我们推荐的方式是代码块的首行用3个反引号`和编程语言名称(C、Python等)标记代码块开始，代码块的结尾用3个反引号来闭合代码块。 比如，将一段python代码插入到Markdown，首行用3个反引号来标记代码块，最后一行再用3个反引号来闭合代码块。 12345678import argparseparser = argparse.ArgumentParser(description="calculate X to the power of Y")parser.add_argument('square',type=int,\ help="display a square of a given number")parser.add_argument('-v',"--verbosity",type=int,choices=[0,1,2],\ default=1,help="increase output verbosity")args = parser.parse_args()answer = args.square ** 2 那么其显示效果为： 1234567891011121314import argparseparser = argparse.ArgumentParser(description="calculate X to the power of Y")parser.add_argument('square',type=int,\ help="display a square of a given number")parser.add_argument('-v',"--verbosity",type=int,choices=[0,1,2],\ default=1,help="increase output verbosity")args = parser.parse_args()answer = args.square ** 2 其他考虑HTML和CSS(使用列表的话，下面的会显示出作用，而不是以代码的形式显示出来) 1.分割线和空行 /*分割线*/ &lt;hr /&gt; /*空行*/ &lt;br /&gt; 2.引用 &lt;blockquote&gt;引用内容&lt;/blockquote&gt; /*如果上下间距很小，可以加个P*/ &lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt; 3.居中与右对齐 /*居中*/ &lt;center&gt;内容&lt;/center&gt; /*右对齐*/ &lt;p style=&quot;text-align:right&quot;&gt;内容&lt;/p&gt; 4.字体大小和颜色 &lt;font colr=&quot;#xxxxxx&quot; size=&quot;numbr&quot;&gt;内容&lt;/font&gt; //详细请查看W3schcool：https://www.w3school.com.cn/tags/tag_font.asp 5.Todo list &lt;ul&gt; &lt;li&gt;&lt;i class=&quot;fa fa-check-square&quot;&gt;&lt;/i&gt;已完成&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;fa fasquare&quot;&gt;&lt;/i&gt;未完成&lt;/li&gt; &lt;/ul&gt; Markdown 高阶语法内容目录在段落中填写[TOC]以显示全文内容的目录结构 [TOC] 标签分类在编辑区任意行的的列首位置输入以下代码给文稿标签： 标签: 数学 英语 Markdown 或者 Tags: 数学 英语 Markdown 删除线使用~~ 表示删除线。 ~~ 这是一段错误的文本 ~~ 脚注使用[^keyword]表示脚注 这是一个脚注1的样例 LaTex公式$表示行内公式 质能守恒方程 $E=mc2 这里的上标我使用sup / sup，用四个尖括号括起来，同样下标为sub 而$$表示整行公式，具体参考MathJax 参考网址：Cmd Markdown简明语法手册 Markdown入门基础 fontawesome reuixiy 后话 第一篇markdown写的文章弄的我好辛苦，主要是用markdownpad编辑好的和hexo解析出的html不一样，在网页上看到的不是自己想要的，后面希望会好一点吧！！]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
